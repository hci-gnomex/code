package hci.dictionary.model;

import hci.framework.utilities.XMLReflectException;
import hci.hibernate5utils.HibernateDetailObject;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;

import org.jdom.Attribute;
import org.jdom.Document;
import org.jdom.Element;

/**
 * Base class for dictionaries that make use of the HCIDictionary API.
 * <p>
 * Classes extending DictionaryEntry retain all the features and behaviors of
 * HibernateDetailObject, but also gain XML functionality specific to
 * dictionaries. The abstract methods in this Class define implementation
 * specific functionality, which extending classes must implement to work with
 * this API.
 * <p>
 * Developers may occationally find it useful to have their standard
 * DetailObjects extend this class, if they would like to use their model object
 * as a dictionary in some cases. Doing so will not interfere with any of the
 * DetailObject's standard functionality.
 * <p>
 * Note that when implementing classes are expressed as XML, the XML element for
 * this dictionary will contain attributes for every member of the subclass for
 * which there is a public get method, not just the display and value fields.
 * 
 * @author Cody Haroldsen
 * @version 1.0
 * @since 11/4/2005
 */
public abstract class DictionaryEntry extends HibernateDetailObject implements Cloneable, Comparable {
  protected boolean canWrite = false;
  public static boolean adminOnly = false;
  public String datakey;

  /**
   * This method makes the DictionaryEntry object comparable so that it can be
   * sorted.
   * 
   * @param anotherDictionaryEntry
   *          the DictionaryEntry to compare this object to.
   * @return 0 if the argument's display is equal to this display; less than 0
   *         if this display is lexicographically less than the argument's
   *         display; and a value greater than 0 if this display is
   *         lexicographically greater than the argument's display.
   */
  public int compareTo(Object anotherDictionaryEntry) {
    if (anotherDictionaryEntry == null && this.getDisplay() == null)
      return 0;
    else if (anotherDictionaryEntry == null && this.getDisplay() != null)
      return this.getDisplay().compareTo("");
    else if (anotherDictionaryEntry != null && this.getDisplay() == null)
      return (new String("")).compareTo(((DictionaryEntry) anotherDictionaryEntry).getDisplay());
    return this.getDisplay().compareTo(((DictionaryEntry) anotherDictionaryEntry).getDisplay());
  }

  /**
   * @return Returns canRead.
   */
  public String getCanRead() {
    if (!canRead) {
      return "N";
    } else {
      return "Y";
    }
  }

  /**
   * @return Returns canWrite.
   */
  public String getCanWrite() {
    if (!canWrite) {
      return "N";
    } else {
      return "Y";
    }
  }

  public String getCanUpdate() {
    if (!canUpdate) {
      return "N";
    } else {
      return "Y";
    }

  }

  public String getCanDelete() {
    if (!canDelete) {
      return "N";
    } else {
      return "Y";
    }

  }

  public Object clone() throws CloneNotSupportedException {
    return super.clone();
  }

  /**
   * @param canWrite
   *          The canWrite to set.
   */
  public void setCanWrite(boolean canWrite) {
    this.canWrite = canWrite;
  }

  public boolean isAdminOnly() {
    return adminOnly;
  }

  public void setAdminOnly(boolean adminOnly) {
    this.adminOnly = adminOnly;
  }

  /**
   * Returns the display string associated with this entry's value
   * 
   * @return The display string for this dictionary entry
   */
  public abstract String getDisplay();

  /**
   * Returns a unique value for this dictionary entry. Normally this would be
   * the PK for the dictionary entry, but it could also be some sort of
   * composite identifier for the entry (in the case of compound primary keys,
   * for example)
   * 
   * @return The value for this dictionary entry
   */
  public abstract String getValue();

  public String getDatakey() {
    return getValue();
  }

  /**
   * Registers a get method to be excluded from XML generated by any of the
   * toXML methods.
   */
  public void registerMethodsToExcludeFromXML() {
    this.excludeMethodFromXML("getExcludedMethodsMap");
    this.excludeMethodFromXML("isAdminOnly");
    super.registerMethodsToExcludeFromXML();
  }

  /**
   * Returns the private HashMap of excluded methods. Used by the
   * DictionaryManager to create the COD editor.
   * 
   * @return the hash map of excluded methods
   */
  public HashMap getExcludedMethodsMap() {
    return this.excludeMethodsFromXML;
  }

  /**
   * Returns this dictionary object as xml using reflection. Unlike the standard
   * toXMLString() method in HibernateDetailObject, this does not include nodes
   * for collections, and always uses the base class (Dictionary or
   * DictionaryEntry, rather than a subclass) as the root node
   * 
   * @param maxLengths
   *          A hashmap mapping field names to the maximum length of the values
   *          encountered for that field
   * @return an XML string representing this dictionary
   */
  public String toDictionaryXML(HashMap maxLengths) throws XMLReflectException {
    String result = null;

    Document doc = this.toDictionaryXMLDoc(DATE_OUTPUT_SLASH, maxLengths);
    org.jdom.output.XMLOutputter out = new org.jdom.output.XMLOutputter();
    result = out.outputString(doc);

    return result;
  }

  /**
   * Perform the XML Formatting. Will not process if is already in Traversal (to
   * avoid circular references).
   *
   * Format dates using dateOutputStyle parameter, but override if instance has
   * set its own dateOutputStyle property. Pass parameter on in recursion.
   *
   * Always uses the base class at the root xml node. Pass list on in recursion.
   * 
   * @param dateOutputStyle
   *          The style to use to forat dates, as specified in DetaiObject
   * @param maxLengths
   *          A hashmap mapping field names to the maximum length of the values
   *          encountered for that field
   * @return An XML document representing the dictionary
   *
   */
  public Document toDictionaryXMLDoc(int dateOutputStyle, HashMap maxLengths) throws XMLReflectException {
    // Call registerMethodsToExcludeFromXML() in case subclass has overridden it
    registerMethodsToExcludeFromXML();
    // Initialize the excludeMethodsFromXML, if still needed
    if (this.excludeMethodsFromXML == null) {
      initExcludeMethodsFromXML();
    }

    // use parameter for local dateOutputStyle
    int dateOutputStyleLocal = dateOutputStyle;
    // But if instance has a value, use it instead
    if (this.dateOutputStyle != DATE_OUTPUT_UNKNOWN) {
      dateOutputStyleLocal = this.dateOutputStyle;
    }

    Class clazz = this.getClass();

    // our class name, the root element of the xml and the prefix to the row
    String clazzName = this.getBaseClassName();

    // our main element and document
    Element mainEle = new Element(clazzName);
    if (isInTraversal()) {
      Attribute a = new Attribute("repeat", "true");
      mainEle.setAttribute(a);
      return new Document(mainEle);
    }

    // set state to in traversal
    this.setInTraversal();

    Document doc = new Document(mainEle);

    Method[] methods = clazz.getMethods();

    // iterate through the fields
    for (int i = 0; i < methods.length; i++) {
      // if this is a wrapper or primative field get the value for our xml

      Method currMethod = methods[i];
      String fieldName = null;

      String mn = currMethod.getName();

      if ((this.excludeMethodsFromXML == null || this.excludeMethodsFromXML.get(mn) == null) && mn.indexOf("get") != -1
          && currMethod.getParameterTypes().length == 0) {
        // we have a getter
        fieldName = mn.substring(3, 4).toLowerCase() + ((mn.length() > 4) ? mn.substring(4) : "");

        // Handle fields that start with a capital letter
        try {
          clazz.getDeclaredField(fieldName);
        } catch (Exception e) {
          try {
            clazz.getDeclaredField(fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1));
            fieldName = fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);
          } catch (Exception ex) {
          }
        }

        Class<?> type = currMethod.getReturnType();

        // take care of 1:1 relationships
        try {
          Object o = currMethod.invoke(this);

          if (o == null) {
            o = "";
          }

          // if (type.getSuperclass() != null &&
          // type.getSuperclass().getName().equals("hci.framework.model.DetailObject"))
          // {
          Method meth = null;
          try {
            meth = type.getMethod("toDictionaryXMLDoc", new Class[] { Integer.TYPE });
          }
          // for errors, do nothing - let it be null
          catch (SecurityException ex) {
          } catch (NoSuchMethodException ex) {
          }
          if (meth != null && !o.equals("")) {// && o instanceof
                                              // java.util.Collection) {
            // If we have a complex class, create an attribute element and put
            // class details inside
            Element attEle = new Element(fieldName);
            Document d = (Document) meth.invoke(o, new Object[] { new Integer(dateOutputStyle) });
            if (d != null) {
              attEle.addContent(d.getRootElement());
            }
            mainEle.addContent(attEle);

          } else if (o != null && type.getInterfaces() != null && type.getInterfaces().length > 0) {
            boolean notCollection = true;
            for (int j = 0; j < type.getInterfaces().length; j++) {
              Class[] intf = type.getInterfaces();
              if (intf[j].getName().equals("java.util.Set") || intf[j].getName().equals("java.util.List") || intf[j].getName().equals("java.util.Collection")) {
                notCollection = false;
              }
            }
            if (notCollection) {
              String convertedDate = this.convertDate(o, dateOutputStyleLocal);
              if (convertedDate != null) {
                mainEle.setAttribute(fieldName, convertedDate);
              } else {
                mainEle.setAttribute(fieldName, o.toString());
              }
            } else {
              // take care of the 1:N
              // iterate through the collection and call toXML or if
              // Wrapper/primative insert values

              if (o instanceof java.util.Collection) {
                Collection coll = (Collection) o;
                Iterator it = coll.iterator();

                while (it.hasNext()) {
                  Object ob = it.next();
                  Class obType = ob.getClass();

                  // if (obType.getSuperclass() != null &&
                  // obType.getSuperclass().getName().equals("hci.framework.model.DetailObject"))
                  // {
                  Method obMeth = null;
                  try {
                    obMeth = obType.getMethod("toDictionaryXMLDoc", new Class[] { Integer.TYPE });
                  }
                  // for errors, do nothing - let it be null
                  catch (SecurityException ex) {
                  } catch (NoSuchMethodException ex) {
                  }
                  if (obMeth != null) {
                    Document obd = (Document) obMeth.invoke(ob, new Object[] { new Integer(dateOutputStyle) });
                    mainEle.addContent(obd.getRootElement());
                  }
                }
              }
            }
          } else {
            String convertedDate = this.convertDate(o, dateOutputStyleLocal);
            if (convertedDate != null) {
              mainEle.setAttribute(fieldName, convertedDate);
            } else {
              mainEle.setAttribute(fieldName, o.toString());
            }
          }

          // Update the maximum length of the field, if necessary
          String fieldValue = mainEle.getAttributeValue(fieldName);
          if (fieldValue != null) {
            if (maxLengths.containsKey(fieldName)) {
              Integer max = (Integer) maxLengths.get(fieldName);
              int fieldLen = fieldValue.length();
              if (max.intValue() < fieldLen) {
                maxLengths.put(fieldName, new Integer(fieldLen));
              }
            } else {
              int fieldLen = fieldValue.length();
              maxLengths.put(fieldName, new Integer(fieldValue.length()));
            }
          }

        } catch (InvocationTargetException ex) {
          throw new XMLReflectException("unable to reflect XML in class " + this.getClass().getName());
        } catch (SecurityException ex) {
          throw new XMLReflectException("unable to reflect XML in class " + this.getClass().getName());
        } catch (IllegalAccessException ex) {
          throw new XMLReflectException("unable to reflect XML in class " + this.getClass().getName());
        } catch (IllegalArgumentException ex) {
          throw new XMLReflectException("unable to reflect XML in class " + this.getClass().getName());
        }

      }
    }

    // doc.getRootElement().addContent(mainEle);

    // if we marked it for traversal, then clear it
    this.clearInTraversal();
    return doc;
  }

  public int compare(Object one, Object two) {
    int result = 1;

    if (one != null && two != null && one instanceof DictionaryEntry && two instanceof DictionaryEntry) {

      DictionaryEntry o1 = (DictionaryEntry) one;
      DictionaryEntry o2 = (DictionaryEntry) two;

      if (o1.getDisplay() != null && o2.getDisplay() != null) {
        result = o1.getDisplay().compareTo(o2.getDisplay());
      }

      if (result == 0) {
        result = 1;
      }
    }
    return result;
  }

  public String getFieldValueString(String fieldName) {
    String value = null;
    String methodName = "get" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);

    try {
      Method m = this.getClass().getMethod(methodName, new Class[] {});
      Object o = m.invoke(this, new Object[] {});

      if (o != null) {
        value = o.toString();
      }
    } catch (Exception e) {
    }

    return value;
  }

  /**
   * Formats a date object as a string, according to the specified format
   * 
   * @param object
   *          The date object to be formatted as a String
   * @param outputStyle
   *          The style in which to forat the date, as specified in DetailObject
   * @return A string representing the date object, formatted as specified
   */
  private String convertDate(Object o, int outputStyle) {
    String result = null;
    if (o != null) {
      if ((o instanceof java.sql.Date)) {
        java.sql.Date d = (java.sql.Date) o;
        result = this.formatDate(d, outputStyle);
      } else if ((o instanceof java.sql.Timestamp)) {
        java.sql.Timestamp t = (java.sql.Timestamp) o;
        result = this.formatTimestamp(t, outputStyle);
      } else if ((o instanceof java.util.Date)) {
        java.util.Date d = (java.util.Date) o;
        result = this.formatDateTime(d, outputStyle);
      }
    }

    return result;
  }
}
